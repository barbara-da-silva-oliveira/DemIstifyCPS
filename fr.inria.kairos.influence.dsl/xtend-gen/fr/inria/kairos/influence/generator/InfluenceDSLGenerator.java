/**
 * generated by Xtext 2.38.0
 */
package fr.inria.kairos.influence.generator;

import fr.inria.kairos.influence.metamodel.influenceMetamodel.Influence;
import java.io.StringWriter;
import java.util.Set;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.TreeIterator;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtext.generator.AbstractGenerator;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGeneratorContext;
import org.eclipse.xtext.xbase.lib.InputOutput;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.jgrapht.alg.cycle.CycleDetector;
import org.jgrapht.graph.DefaultDirectedGraph;
import org.jgrapht.graph.DefaultEdge;
import org.jgrapht.nio.dot.DOTExporter;

@SuppressWarnings("all")
public class InfluenceDSLGenerator extends AbstractGenerator {
  @Override
  public void doGenerate(final Resource resource, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    String infoFile = "Quick Info:";
    final StringBuilder jsonFile = new StringBuilder();
    jsonFile.append("{\n\t\"influences\": [\n");
    DefaultDirectedGraph<String, DefaultEdge> graph = new DefaultDirectedGraph<String, DefaultEdge>(DefaultEdge.class);
    final TreeIterator<EObject> ite = resource.getAllContents();
    while (ite.hasNext()) {
      {
        final EObject content = ite.next();
        if ((content instanceof Influence)) {
          final Influence inf = ((Influence) content);
          jsonFile.append("\t\t{\n");
          jsonFile.append("\t\t\t\"name\": \"").append(inf.getName()).append("\",\n");
          jsonFile.append("\t\t\t\"sources\": \"").append(IterableExtensions.join(inf.getSourceArtifact(), ", ")).append("\",\n");
          jsonFile.append("\t\t\t\"targets\": \"").append(IterableExtensions.join(inf.getTargetArtifact(), ", ")).append("\"\n");
          jsonFile.append("\t\t},\n");
          String _infoFile = infoFile;
          String _name = inf.getName();
          String _plus = (_name + ":");
          EList<String> _sourceArtifact = inf.getSourceArtifact();
          String _plus_1 = (_plus + _sourceArtifact);
          String _plus_2 = (_plus_1 + "\n\t->\n\t");
          EList<String> _targetArtifact = inf.getTargetArtifact();
          String _plus_3 = (_plus_2 + _targetArtifact);
          String _plus_4 = (_plus_3 + "\n");
          infoFile = (_infoFile + _plus_4);
          EList<String> _sourceArtifact_1 = inf.getSourceArtifact();
          for (final String sourceName : _sourceArtifact_1) {
            EList<String> _targetArtifact_1 = inf.getTargetArtifact();
            for (final String targetName : _targetArtifact_1) {
              {
                graph.addVertex(sourceName);
                graph.addVertex(targetName);
                graph.addEdge(sourceName, targetName);
                InfluenceDSLGenerator.detectCycle(graph);
              }
            }
          }
        }
      }
    }
    this.exportGraphToDot(graph, fsa, "influenceGraph.dot");
    fsa.generateFile("influences.json", jsonFile.toString());
    fsa.generateFile("info.txt", infoFile.toString());
  }

  public void exportGraphToDot(final DefaultDirectedGraph<String, DefaultEdge> graph, final IFileSystemAccess2 fsa, final String filename) {
    final DOTExporter<String, DefaultEdge> dotExporter = new DOTExporter<String, DefaultEdge>();
    final StringWriter writer = new StringWriter();
    dotExporter.exportGraph(graph, writer);
    fsa.generateFile(filename, writer.toString());
  }

  public static boolean detectCycle(final DefaultDirectedGraph<String, DefaultEdge> graph) {
    final CycleDetector<String, DefaultEdge> cycleDetector = new CycleDetector<String, DefaultEdge>(graph);
    boolean _detectCycles = cycleDetector.detectCycles();
    if (_detectCycles) {
      Set<String> _findCycles = cycleDetector.findCycles();
      String _plus = ("Cycle detected" + _findCycles);
      InputOutput.<String>println(_plus);
      return true;
    } else {
      InputOutput.<String>println("No cycles detected");
      return false;
    }
  }
}
